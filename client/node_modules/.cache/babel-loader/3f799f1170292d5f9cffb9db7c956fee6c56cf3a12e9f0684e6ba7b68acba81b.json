{"ast":null,"code":"var _jsxFileName = \"/Users/beluga/Documents/Dev/React/audio_visualizer/src/components/Visualizer4.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useCallback } from \"react\";\nimport \"./index.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Visualizer4 = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const analyser = useRef(null);\n  const devicePixelRatio = window.devicePixelRatio || 1;\n  const visualizeData = useCallback(() => {\n    let animationController;\n    animationController = window.requestAnimationFrame(visualizeData);\n    if (!analyser.current) {\n      return cancelAnimationFrame(animationController);\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    canvas.width = canvas.offsetWidth * devicePixelRatio;\n    canvas.height = canvas.offsetHeight * devicePixelRatio;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n    ctx.scale(devicePixelRatio, devicePixelRatio);\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n    const bufferLength = analyser.current.frequencyBinCount;\n    const dataArray = new Uint32Array(bufferLength);\n    analyser.current.getFloatTimeDomainData(dataArray);\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.lineWidth = 2.5;\n    ctx.strokeStyle = \"green\";\n    ctx.beginPath();\n    const sliceWidth = WIDTH * 1.0 / bufferLength;\n    let x = 0;\n    for (let i = 0; i < bufferLength; i++) {\n      const v = dataArray[i] / 128.0;\n      // const v = dataArray[i] / 128.0;\n      const y = v * HEIGHT / 2;\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n      x += sliceWidth;\n    }\n    ctx.lineTo(canvas.width, canvas.height / 2);\n    ctx.stroke();\n  }, [devicePixelRatio]);\n  const handleAudioPlay = useCallback(async () => {\n    if (!analyser.current) {\n      try {\n        // Get audio stream from mic input  - WORKS!!\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        const audioContext = new AudioContext();\n        const audioSrc = audioContext.createMediaStreamSource(stream);\n        analyser.current = audioContext.createAnalyser();\n        audioSrc.connect(analyser.current);\n        // analyser.current.connect(audioContext.destination);\n\n        // analyser.current.fftSize = 2 ** 200;\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    visualizeData();\n  }, [visualizeData]);\n  useEffect(() => {\n    handleAudioPlay();\n  }, [handleAudioPlay]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: 500,\n      height: 500\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 7\n    }, this)\n  }, void 0, false);\n};\n_s(Visualizer4, \"g//cZSBBS12s9YDnalyJ9diIAFM=\");\n_c = Visualizer4;\nexport default Visualizer4;\nvar _c;\n$RefreshReg$(_c, \"Visualizer4\");","map":{"version":3,"names":["React","useRef","useEffect","useCallback","jsxDEV","_jsxDEV","Fragment","_Fragment","Visualizer4","_s","canvasRef","analyser","devicePixelRatio","window","visualizeData","animationController","requestAnimationFrame","current","cancelAnimationFrame","canvas","width","offsetWidth","height","offsetHeight","ctx","getContext","scale","WIDTH","HEIGHT","bufferLength","frequencyBinCount","dataArray","Uint32Array","getFloatTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","v","y","moveTo","lineTo","stroke","handleAudioPlay","stream","navigator","mediaDevices","getUserMedia","audio","audioContext","AudioContext","audioSrc","createMediaStreamSource","createAnalyser","connect","error","console","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/beluga/Documents/Dev/React/audio_visualizer/src/components/Visualizer4.tsx"],"sourcesContent":["import React, { useRef, useEffect, useCallback } from \"react\";\n\nimport \"./index.css\";\n\nconst Visualizer4: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const analyser = useRef<AnalyserNode | null>(null);\n  const devicePixelRatio = window.devicePixelRatio || 1;\n\n  \n  const visualizeData = useCallback(() => {\n    let animationController: number | null;\n    animationController = window.requestAnimationFrame(visualizeData);\n\n    if (!analyser.current) {\n      return cancelAnimationFrame(animationController!);\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    canvas.width = canvas.offsetWidth * devicePixelRatio;\n    canvas.height = canvas.offsetHeight * devicePixelRatio;\n    \n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    ctx.scale(devicePixelRatio, devicePixelRatio);\n    \n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n    const bufferLength = analyser.current.frequencyBinCount;\n    const dataArray = new Uint32Array(bufferLength);\n    analyser.current.getFloatTimeDomainData(dataArray);\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.lineWidth = 2.5;\n    ctx.strokeStyle = \"green\";\n    ctx.beginPath();\n    const sliceWidth = (WIDTH * 1.0) / bufferLength;\n    let x = 0;\n    for (let i = 0; i < bufferLength; i++) {\n      const v = dataArray[i] / 128.0;\n      // const v = dataArray[i] / 128.0;\n      const y = (v * HEIGHT) / 2;\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n      x += sliceWidth;\n    }\n    ctx.lineTo(canvas.width, canvas.height / 2);\n    ctx.stroke();\n  }, [devicePixelRatio]);\n  \n  \n  const handleAudioPlay = useCallback(async () => {\n    if (!analyser.current) {\n      try {\n        // Get audio stream from mic input  - WORKS!!\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        const audioContext = new AudioContext();\n        const audioSrc = audioContext.createMediaStreamSource(stream);\n        analyser.current = audioContext.createAnalyser();\n        audioSrc.connect(analyser.current);\n        // analyser.current.connect(audioContext.destination);\n\n        // analyser.current.fftSize = 2 ** 200;\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    visualizeData();\n  }, [visualizeData]);\n  \n\n  useEffect(() => {\n    handleAudioPlay();\n  }, [handleAudioPlay])\n\n\n  return (\n    <>\n      {/* <button onClick={handleAudioPlay}>begin</button> */}\n      <canvas ref={canvasRef} width={500} height={500} />\n    </>\n  );\n};\n\nexport default Visualizer4;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}