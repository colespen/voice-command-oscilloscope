{"ast":null,"code":"var _jsxFileName = \"/Users/beluga/Documents/Dev/React/audio_visualizer/src/components/Visualizer3.tsx\",\n  _s = $RefreshSig$();\nimport React, { useRef } from \"react\";\nimport \"./index.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst Visualizer4 = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const analyser = useRef(null);\n  let animationController;\n\n  // Store previous waveform points\n  const prevWaveformPoints = useRef([]);\n  const handleAudioPlay = async () => {\n    const audioContext = new AudioContext();\n    if (!analyser.current) {\n      try {\n        // Get audio stream from mic input\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        const audioSrc = audioContext.createMediaStreamSource(stream);\n        analyser.current = audioContext.createAnalyser();\n        audioSrc.connect(analyser.current);\n        analyser.current.connect(audioContext.destination);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    visualizeData();\n  };\n  const visualizeData = () => {\n    animationController = window.requestAnimationFrame(visualizeData);\n    if (!analyser.current) {\n      return cancelAnimationFrame(animationController);\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) {\n      return;\n    }\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      return;\n    }\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n    const bufferLength = analyser.current.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    analyser.current.getByteTimeDomainData(dataArray);\n\n    // Store the latest waveform points\n    const waveformPoints = [];\n    const sliceWidth = WIDTH * 1.0 / bufferLength;\n    let x = 0;\n    for (let i = 0; i < bufferLength; i++) {\n      const v = dataArray[i] / 128.0;\n      const y = v * HEIGHT / 2;\n      waveformPoints.push(x, y + HEIGHT / 2);\n      x += sliceWidth;\n    }\n\n    // Connect the newly obtained waveform points with the previous ones\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"green\";\n    ctx.beginPath();\n    ctx.moveTo(prevWaveformPoints.current[prevWaveformPoints.current.length - 2], prevWaveformPoints.current[prevWaveformPoints.current.length - 1]);\n    for (let i = 0; i < waveformPoints.length; i += 2) {\n      ctx.lineTo(waveformPoints[i], waveformPoints[i + 1]);\n    }\n    ctx.stroke();\n\n    // Update the previous waveform points\n    prevWaveformPoints.current = waveformPoints;\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleAudioPlay,\n      children: \"begin\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: 500,\n      height: 500\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n_s(Visualizer4, \"dGO3xEXEQMx4eLrxni/3daQRMNo=\");\n_c = Visualizer4;\nexport default Visualizer4;\nvar _c;\n$RefreshReg$(_c, \"Visualizer4\");","map":{"version":3,"names":["React","useRef","jsxDEV","_jsxDEV","Fragment","_Fragment","Visualizer4","_s","canvasRef","analyser","animationController","prevWaveformPoints","handleAudioPlay","audioContext","AudioContext","current","stream","navigator","mediaDevices","getUserMedia","audio","audioSrc","createMediaStreamSource","createAnalyser","connect","destination","error","console","visualizeData","window","requestAnimationFrame","cancelAnimationFrame","canvas","ctx","getContext","WIDTH","width","HEIGHT","height","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteTimeDomainData","waveformPoints","sliceWidth","x","i","v","y","push","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","moveTo","length","lineTo","stroke","children","onClick","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["/Users/beluga/Documents/Dev/React/audio_visualizer/src/components/Visualizer3.tsx"],"sourcesContent":["import React, { useRef } from \"react\";\n\nimport \"./index.css\";\n\nconst Visualizer4: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const analyser = useRef<AnalyserNode | null>(null);\n\n  let animationController: number | null;\n\n  // Store previous waveform points\n  const prevWaveformPoints = useRef<number[]>([]);\n\n  const handleAudioPlay = async () => {\n    const audioContext = new AudioContext();\n    if (!analyser.current) {\n      try {\n        // Get audio stream from mic input\n        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        const audioSrc = audioContext.createMediaStreamSource(stream);\n        analyser.current = audioContext.createAnalyser();\n        audioSrc.connect(analyser.current);\n        analyser.current.connect(audioContext.destination);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    visualizeData();\n  };\n\n  const visualizeData = () => {\n    animationController = window.requestAnimationFrame(visualizeData);\n    if (!analyser.current) {\n      return cancelAnimationFrame(animationController!);\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) {\n      return;\n    }\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      return;\n    }\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n    const bufferLength = analyser.current.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    analyser.current.getByteTimeDomainData(dataArray);\n\n    // Store the latest waveform points\n    const waveformPoints = [];\n    const sliceWidth = (WIDTH * 1.0) / bufferLength;\n    let x = 0;\n    for (let i = 0; i < bufferLength; i++) {\n      const v = dataArray[i] / 128.0;\n      const y = (v * HEIGHT) / 2;\n      waveformPoints.push(x, y + HEIGHT / 2);\n      x += sliceWidth;\n    }\n\n    // Connect the newly obtained waveform points with the previous ones\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, WIDTH, HEIGHT);\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"green\";\n    ctx.beginPath();\n    ctx.moveTo(prevWaveformPoints.current[prevWaveformPoints.current.length - 2], prevWaveformPoints.current[prevWaveformPoints.current.length - 1]);\n    for (let i = 0; i < waveformPoints.length; i += 2) {\n      ctx.lineTo(waveformPoints[i], waveformPoints[i + 1]);\n    }\n    ctx.stroke();\n\n    // Update the previous waveform points\n    prevWaveformPoints.current = waveformPoints;\n  };\n\n  return (\n    <>\n      <button onClick={handleAudioPlay}>begin</button>\n      <canvas ref={canvasRef} width={500} height={500} />\n    </>\n  );\n};\n\nexport default Visualizer4;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}