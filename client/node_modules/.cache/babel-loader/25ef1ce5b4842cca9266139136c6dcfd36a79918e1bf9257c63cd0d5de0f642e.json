{"ast":null,"code":"let dataArray, sliceWidth;\nonmessage = function (e) {\n  switch (e.data.type) {\n    case \"start\":\n      draw(e.data.payload);\n      break;\n    default:\n      break;\n  }\n};\nfunction draw(data) {\n  const {\n    canvas,\n    analyser,\n    canvasWidth,\n    canvasHeight,\n    bufferLength\n  } = data;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return;\n  }\n  dataArray = new Float32Array(bufferLength);\n  sliceWidth = canvasWidth * 1.0 / bufferLength;\n  analyser.getFloatTimeDomainData(dataArray);\n  ctx.fillStyle = \"black\";\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = \"green\";\n  ctx.beginPath();\n  let x = 0;\n  let y = canvasHeight / 2;\n  for (let i = 0; i < bufferLength; i++) {\n    const v = dataArray[i];\n    const val = v * 0.5;\n    const yOffset = val * canvasHeight;\n    y = canvasHeight / 2 + yOffset;\n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n    x += sliceWidth;\n  }\n  ctx.stroke();\n  postMessage({\n    type: \"draw\"\n  });\n}\nexport {};","map":{"version":3,"names":["dataArray","sliceWidth","onmessage","e","data","type","draw","payload","canvas","analyser","canvasWidth","canvasHeight","bufferLength","ctx","getContext","Float32Array","getFloatTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","x","y","i","v","val","yOffset","moveTo","lineTo","stroke","postMessage"],"sources":["/Users/beluga/Documents/Dev/React/audio_visualizer/src/worker/drawer.ts"],"sourcesContent":["interface MessagePayload {\n  canvas: OffscreenCanvas;\n  analyser: AnalyserNode;\n  canvasWidth: number;\n  canvasHeight: number;\n  bufferLength: number;\n}\n\nlet dataArray: Float32Array,\n  sliceWidth: number;\n\nonmessage = function (e: MessageEvent) {\n  switch (e.data.type) {\n    case \"start\":\n      draw(e.data.payload as MessagePayload);\n      break;\n\n    default:\n      break;\n  }\n};\n\nfunction draw(data: MessagePayload) {\n  const { canvas, analyser, canvasWidth, canvasHeight, bufferLength } = data;\n  const ctx = canvas.getContext(\"2d\");\n\n  if (!ctx) {\n    return;\n  }\n\n  dataArray = new Float32Array(bufferLength);\n  sliceWidth = (canvasWidth * 1.0) / bufferLength;\n\n  analyser.getFloatTimeDomainData(dataArray);\n\n  ctx.fillStyle = \"black\";\n  ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n\n  ctx.lineWidth = 2;\n  ctx.strokeStyle = \"green\";\n\n  ctx.beginPath();\n\n  let x = 0;\n  let y = canvasHeight / 2;\n\n  for (let i = 0; i < bufferLength; i++) {\n    const v = dataArray[i];\n    const val = v * 0.5;\n    const yOffset = val * canvasHeight;\n    y = canvasHeight / 2 + yOffset;\n\n    if (i === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n    x += sliceWidth;\n  }\n  ctx.stroke();\n  postMessage({ type: \"draw\" });\n}\n\nexport {};\n\n"],"mappings":"AAQA,IAAIA,SAAuB,EACzBC,UAAkB;AAEpBC,SAAS,GAAG,SAAAA,CAAUC,CAAe,EAAE;EACrC,QAAQA,CAAC,CAACC,IAAI,CAACC,IAAI;IACjB,KAAK,OAAO;MACVC,IAAI,CAACH,CAAC,CAACC,IAAI,CAACG,OAAO,CAAmB;MACtC;IAEF;MACE;EAAM;AAEZ,CAAC;AAED,SAASD,IAAIA,CAACF,IAAoB,EAAE;EAClC,MAAM;IAAEI,MAAM;IAAEC,QAAQ;IAAEC,WAAW;IAAEC,YAAY;IAAEC;EAAa,CAAC,GAAGR,IAAI;EAC1E,MAAMS,GAAG,GAAGL,MAAM,CAACM,UAAU,CAAC,IAAI,CAAC;EAEnC,IAAI,CAACD,GAAG,EAAE;IACR;EACF;EAEAb,SAAS,GAAG,IAAIe,YAAY,CAACH,YAAY,CAAC;EAC1CX,UAAU,GAAIS,WAAW,GAAG,GAAG,GAAIE,YAAY;EAE/CH,QAAQ,CAACO,sBAAsB,CAAChB,SAAS,CAAC;EAE1Ca,GAAG,CAACI,SAAS,GAAG,OAAO;EACvBJ,GAAG,CAACK,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAER,WAAW,EAAEC,YAAY,CAAC;EAE7CE,GAAG,CAACM,SAAS,GAAG,CAAC;EACjBN,GAAG,CAACO,WAAW,GAAG,OAAO;EAEzBP,GAAG,CAACQ,SAAS,EAAE;EAEf,IAAIC,CAAC,GAAG,CAAC;EACT,IAAIC,CAAC,GAAGZ,YAAY,GAAG,CAAC;EAExB,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,YAAY,EAAEY,CAAC,EAAE,EAAE;IACrC,MAAMC,CAAC,GAAGzB,SAAS,CAACwB,CAAC,CAAC;IACtB,MAAME,GAAG,GAAGD,CAAC,GAAG,GAAG;IACnB,MAAME,OAAO,GAAGD,GAAG,GAAGf,YAAY;IAClCY,CAAC,GAAGZ,YAAY,GAAG,CAAC,GAAGgB,OAAO;IAE9B,IAAIH,CAAC,KAAK,CAAC,EAAE;MACXX,GAAG,CAACe,MAAM,CAACN,CAAC,EAAEC,CAAC,CAAC;IAClB,CAAC,MAAM;MACLV,GAAG,CAACgB,MAAM,CAACP,CAAC,EAAEC,CAAC,CAAC;IAClB;IACAD,CAAC,IAAIrB,UAAU;EACjB;EACAY,GAAG,CAACiB,MAAM,EAAE;EACZC,WAAW,CAAC;IAAE1B,IAAI,EAAE;EAAO,CAAC,CAAC;AAC/B;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}